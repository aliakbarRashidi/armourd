{"name":"Armourd","tagline":"a Linux daemon for service recovery","body":"armourd\r\n=======\r\n\r\narmourd is a Linux daemon for service recovery and is targeted for use in\r\nembedded systems running GNU/Linux.\r\n\r\nWhen a watched application crashes, armourd will automatically restart it. To\r\nwatch an application armourd only needs the file path of the application\r\nexecutable; no PID files, no shell scripts. This is achieved by jointly\r\ntracking the creation/termination of processes and collecting process\r\ninformation.\r\n\r\nIt works out of the box, as it takes roughly a couple of minutes to set it up.\r\nUpon startup armourd interprets its configuration file which lists the \r\npathnames of the services that need to be watched.\r\n\r\narmourd recovers processes that stopped abnormally, by returning a nonzero exit\r\ncode; it does not recover applications hanging. Forking servers will have their\r\nchildren terminate before restart. Although it is designed to recover system\r\ndaemon programs, it can actually recover any application, with the limitation\r\nthat currently only supports single-instance applications unless using the DBus\r\ninterface (see below).\r\n\r\narmourd is Linux-only by design, because it relies upon interfaces such as\r\nepoll(7) or netlink(7) and proc(5) files that aren't available in other unices.\r\nIt is more suited to sysvinit-based systems; newer init systems, such as\r\nupstart or systemd, service recovery is readily available.\r\n\r\nOptionally, you can build the daemon with \r\n[DBus](http://www.freedesktop.org/wiki/Software/dbus/) support to commuincate \r\nwith other applications. The DBus API exposes runtime information, and a method\r\nto watch running processes.\r\n\r\nGoals\r\n-----\r\n\r\n* simplest possible configuration\r\n* no library dependencies (other than the C library)\r\n* small memory footprint\r\n* fast recovery of processes\r\n\r\n\r\nUsage\r\n-----\r\n\r\nPopulate the config file with the (absolute) pathnames of your applications,\r\ne.g.:\r\n\r\n        $ echo '/opt/foo' > /etc/armourd.conf\r\n\r\nYou can also use file-name globs ('*' wildcard). For example, to add all the\r\nbinaries under /usr/local/bin/:\r\n\r\n        $ echo '/usr/local/bin/*' > /etc/armourd.conf\r\n\r\nAdditionally, you may explicitly request to watch a running process, using\r\nDBus, e.g. with `dbus-send` you would:\r\n\r\n        $ dbus-send --session --print-reply --type=method_call \\\r\n        > --dest=com.github.Armourd /com/github/armourd \\\r\n        > com.github.Armourd.WatchProcess int32:`pidof foo`\r\n\r\nOr, using the provided example Python script:\r\n\r\n        $ ./client-example.py -w`pidof foo`\r\n\r\n\r\nDBus interface\r\n--------------\r\nTODO\r\n\r\nTestsuite\r\n---------\r\n\r\nCurrent version is not production ready, as there aren't any tests.  Unit tests\r\nto exercise the API's and integration tests to check the runtime behaviour are\r\na must.  This could be added as a configure option (e.g. --enable-tests) then\r\nthe user can run the make *check* target\r\n\r\nNotes\r\n-----\r\n\r\narmourd just does individual service recovery; it does not perform system\r\nrecovery, i.e. talk to watchdog hardware.  In order to make your system fully\r\nreliable, you should have a process feeding a watchdog, although your mileage\r\nmay vary.  Linux provides a very simple interface to watchdog timers\r\n(`/dev/watchdog`) that armourd will implement as a non-default feature, to\r\nprovide an all-round solution.\r\n\r\nTODO\r\n----\r\n\r\n* Testsuite\r\n* Logging\r\n* Configuration file parser needs to be rewritten (it is buggy)\r\n* Enable options in the configuration file and DBus interface to tailor\r\n  specific needs, e.g. return codes for success or a recover script\r\n* watchdog capabilities\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}