{"name":"armourd","tagline":"a Linux daemon for process monitoring","body":"armourd\r\n=======\r\n\r\n> A Linux daemon for process monitoring targeted at embedded systems running GNU/Linux.\r\n\r\narmourd restarts processes that stopped abnormally, by returning a nonzero exit\r\ncode. To watch an application armourd only needs the file path of the application\r\nexecutable; no PID files, *no shell scripts*.\r\n\r\nIt works out of the box, as it takes roughly a couple of minutes to set it up.\r\nUpon startup armourd interprets its configuration file,\r\nwhich lists the pathnames of the services that need to be watched, e.g.:\r\n\r\n```sh\r\n$ echo '/opt/foo' > /etc/armourd.conf\r\n$ echo '/opt/bar' >> /etc/armourd.conf\r\n```\r\nYou can also use file-name globs ('*' wildcard). For example, to watch all the\r\nbinaries under /usr/local/bin/:\r\n\r\n```sh\r\n$ echo '/usr/local/bin/*' > /etc/armourd.conf\r\n```\r\n\r\nSee [INSTALL](INSTALL) for details on how to build and run.\r\n\r\nGoals\r\n-----\r\n\r\n* simplest possible configuration\r\n* no library dependencies (other than the C library)\r\n* small memory footprint\r\n* fast recovery of processes\r\n\r\nCaveats\r\n-------\r\n\r\narmourd is Linux-only by design, because it relies upon interfaces such as\r\n[epoll(7)](http://man7.org/linux/man-pages/man7/epoll.7.html) or [netlink(7)](http://man7.org/linux/man-pages/man7/netlink.7.html) \r\nand [proc(5)](http://man7.org/linux/man-pages/man5/proc.5.html) \r\nfiles that aren't available in other unices.\r\nIt is more suited to sysvinit-based systems; newer init systems, such as\r\n[upstart](http://upstart.ubuntu.com/) or [systemd](http://www.freedesktop.org/wiki/Software/systemd/), \r\nservice recovery is readily available.\r\n\r\narmourd does not start services, i.e. its not an init daemon; on the other hand, \r\nit runs independently of your init system, and thus is portable across Linux devices.\r\n\r\nForking servers will have their children terminate before restart. Although it is \r\ndesigned to recover system daemon programs, it can actually recover any application, \r\nwith the limitation that currently only supports single-instance applications \r\nunless using the [D-Bus](http://dbus.freedesktop.org/) interface (see below).\r\n\r\n*It does not recover applications hanging*. \r\n\r\nDependencies\r\n------------\r\n\r\nThe minimum required versions are:\r\n\r\n* Linux kernel 2.6.27\r\n* GNU C Library (glibc) 2.8\r\n* GCC 4.1\r\n* Autoconf 2.50\r\n* D-Bus 1.6.x (not required)\r\n\r\nSystem Recovery\r\n---------------\r\n\r\narmourd can also be configured to talk to watchdog hardware.  In order to \r\nmake your system fully reliable, you should have a process feeding a watchdog, \r\nalthough your mileage may vary.  Linux provides a very simple interface to watchdog timers\r\n(`/dev/watchdog`) that armourd implements as a non-default feature, to\r\nprovide an all-round solution. To enable it:\r\n```\r\n./configure --enable-watchdog\r\n```\r\n\r\nD-Bus Interface\r\n---------------\r\n\r\nOptionally, you can build the daemon with D-Bus support to commuincate with other \r\napplications. The D-Bus API exposes runtime information, and a method to watch \r\nrunning processes. The introspection XML data is:\r\n\r\n```xml\r\n<node>\r\n  <interface name=\"org.freedesktop.DBus.Introspectable\">\r\n    <method name=\"Introspect\">\r\n      <arg name=\"xml_data\" type=\"s\" direction=\"out\"/>\r\n  </method>\r\n  </interface>\r\n  <interface name=\"com.github.Armourd\">\r\n    <method name=\"ListProcesses\">\r\n      <arg type=\"a{sv}\" direction=\"out\"/>\r\n    </method>\r\n    <method name=\"WatchProcess\">\r\n      <arg name=\"pid\" type=\"i\" direction=\"in\"/>\r\n      <arg name=\"resultcode\" type=\"u\" direction=\"out\"/>\r\n    </method>\r\n  </interface>\r\n</node>\r\n```\r\n\r\nExamples\r\n--------\r\n\r\nExplicitly request to watch a running process, using\r\nDBus, e.g. with `dbus-send` you would:\r\n\r\n```sh\r\n$ dbus-send --session --print-reply --type=method_call \\\r\n> --dest=com.github.Armourd /com/github/armourd \\\r\n> com.github.Armourd.WatchProcess int32:`pidof foo`\r\n```\r\nOr, using the [example](src/dbus/client-example.py) Python script:\r\n\r\n```sh\r\n$ ./client-example.py -w`pidof foo`\r\n```\r\n\r\n\r\nSee http://www.linuxfromscratch.org/blfs/view/svn/general/dbus.html for an example of how to build D-Bus\r\n\r\nTestsuite\r\n---------\r\n\r\nCurrent version is not production ready, as there aren't any tests.  Unit tests\r\nto exercise the API's and integration tests to check the runtime behaviour are\r\na must.  This could be added as a configure option (e.g. --enable-tests) then\r\nthe user can run the make *check* target\r\n\r\nTODO\r\n----\r\n\r\n* Testsuite\r\n* Logging\r\n* Configuration file parser needs to be rewritten (it is buggy)\r\n* Enable options in the configuration file and DBus interface to tailor\r\n  specific needs, e.g. return codes for success, recover script, etc.\r\n* Send a D-Bus signal when a watched application crashes/restarts\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}